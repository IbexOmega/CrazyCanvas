#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_NV_mesh_shader : require

#include "../Defines.glsl"

// Number of threads
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;

// Output block for vertices
layout(location = 0) out flat uint	out_MaterialSlot[];
layout(location = 1) out vec3		out_WorldPosition[];
layout(location = 2) out vec3		out_Normal[];
layout(location = 3) out vec3		out_Tangent[];
layout(location = 4) out vec3		out_Bitangent[];
layout(location = 5) out vec2		out_TexCoord[];
layout(location = 6) out vec4		out_ClipPosition[];
layout(location = 7) out vec4		out_PrevClipPosition[];

// Constant data
const vec3 POSITIONS[3] = 
{
	vec3(-1.0f, 1.0f, 0.0f),
	vec3( 0.0f, -1.0f, 0.0f),
	vec3( 1.0f, 1.0f, 0.0f),
};

// Uniforms
layout(binding = 0, set = BUFFER_SET_INDEX) uniform PerFrameBuffer
{
	SPerFrameBuffer Val;
} u_PerFrameBuffer;

// Vertex data
layout(binding = 0, set = DRAW_SET_INDEX) restrict readonly buffer Vertices
{ 
	SVertex Val[]; 
} b_Vertices;

layout(binding = 1, set = DRAW_SET_INDEX) restrict readonly buffer Instances
{ 
	SInstance Val[]; 
} b_Instances;

layout(binding = 2, set = DRAW_SET_INDEX) restrict readonly buffer Meshlets
{ 
	SMeshlet Val[];
} b_Meshlets;

layout(binding = 3, set = DRAW_SET_INDEX) restrict readonly buffer UniqueIndices
{ 
	uint Val[];
} b_UniqueIndices;

layout(binding = 4, set = DRAW_SET_INDEX) restrict readonly buffer PrimitiveIndices
{ 
	uint Val[];
} b_PrimitiveIndices;

/*
* Main
*/
void main()
{
	uint meshletID	= gl_WorkGroupID.x;
	SMeshlet meshlet = b_Meshlets.Val[meshletID];
	SInstance instance = b_Instances.Val[0];

	mat4 projection	= u_PerFrameBuffer.Val.Projection;
	mat4 view		= u_PerFrameBuffer.Val.View;
	
	// Per vertex
	uint indexCount = meshlet.PrimCount * 3;
	uint indexOffset = meshlet.PrimOffset * 3;
	for (uint index = 0; index < indexCount; index++)
	{
		uint uniqueIndex = b_PrimitiveIndices.Val[indexOffset + index];
		uint vertexIndex = b_UniqueIndices.Val[uniqueIndex] + meshlet.VertOffset;

		SVertex vertex		= b_Vertices.Val[vertexIndex];
		vec4 worldPosition	= vec4(vertex.Position.xyz, 1.0f);
		vec3 normal			= vertex.Normal.xyz;
		vec3 tangent		= vertex.Tangent.xyz;
		vec2 texcoord		= vertex.TexCoord.xy;

		// Material
		out_WorldPosition[index]	= worldPosition.xyz;
		out_MaterialSlot[index]		= 0;
		out_Normal[index]			= normalize(normal);
		out_Tangent[index]			= normalize(tangent);
		out_Bitangent[index]		= normalize(cross(tangent, normal));
		out_TexCoord[index]			= texcoord;
		
		vec4 clipPosition = projection * view * worldPosition;
		out_ClipPosition[index]		= clipPosition;
		out_PrevClipPosition[index]	= clipPosition;

		// Position
		gl_MeshVerticesNV[index].gl_Position = clipPosition;

		// Triangle indices
		gl_PrimitiveIndicesNV[index] = index;
	}
	
	// Number of triangles
	gl_PrimitiveCountNV = meshlet.PrimCount;
}