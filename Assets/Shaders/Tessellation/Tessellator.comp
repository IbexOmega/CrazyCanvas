#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shader_draw_parameters : enable
#extension GL_GOOGLE_include_directive : enable

#include "../Defines.glsl"

#define WORK_GROUP_INVOCATIONS 32
layout(local_size_x = WORK_GROUP_INVOCATIONS, local_size_y = 1, local_size_z = 1) in;

// Pushconstants
layout(push_constant) uniform PushConstants
{
	uint TriangleCount;
    uint MaxTessellationLevels;
    uint OuterBorder;
} u_PC;

layout(binding = 0, set = 0) restrict readonly buffer InVertices				{ SVertex val[]; }	b_InVertices;
layout(binding = 1, set = 0) restrict readonly buffer InIndices		            { uint val[]; }		b_InIndices;

layout(binding = 0, set = 1) restrict writeonly buffer OutVertices				{ SVertex val[]; }	b_OutVertices;
layout(binding = 1, set = 1) restrict writeonly buffer OutIndices		        { uint val[]; }		b_OutIndices;

void main()
{
	// Return in case this thread is outside of our vertex count
	uint totalInvocations = gl_NumWorkGroups.x * gl_WorkGroupSize.x;
	uint triangleIndex = gl_GlobalInvocationID.x;

	while (triangleIndex < u_PC.TriangleCount)
	{
        uint index0 = b_InIndices.val[triangleIndex*3 + 0];
        uint index1 = b_InIndices.val[triangleIndex*3 + 1];
        uint index2 = b_InIndices.val[triangleIndex*3 + 2];

        b_OutVertices.val[index0] = b_InVertices.val[index0];
        b_OutIndices.val[triangleIndex*3 + 0] = index0;

        b_OutVertices.val[index1] = b_InVertices.val[index1];
        b_OutIndices.val[triangleIndex*3 + 1] = index1;

        b_OutVertices.val[index2] = b_InVertices.val[index2];
        b_OutIndices.val[triangleIndex*3 + 2] = index2;
		triangleIndex += totalInvocations;
	}
}