#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : enable
//#extension GL_EXT_debug_printf : enable

#include "Helpers.glsl"
#include "Defines.glsl"
#include "RayTracingInclude.glsl"

layout(location = 0) rayPayloadEXT SRadiancePayload s_RadiancePayload;
layout(location = 1) rayPayloadEXT SShadowPayload 	s_ShadowPayload;

void SampleLights(vec3 w_o, mat3 worldToLocal, inout vec3 L_d, inout vec3 Scatter_f)
{
	//Directional Light
	SLightSample dirLightSample = EvalDirectionalRadiance(w_o, s_RadiancePayload.Albedo, s_RadiancePayload.Metallic, s_RadiancePayload.Roughness, worldToLocal);

	if (dirLightSample.PDF > 0.0f && dot(dirLightSample.L_d, dirLightSample.L_d) > EPSILON)
	{
		//Define Shadow Ray Parameters
		const vec3 		origin 				= s_RadiancePayload.ScatterPosition;
		const vec3 		direction			= dirLightSample.SampleWorldDir;
		const uint 		rayFlags           	= gl_RayFlagsOpaqueEXT/* | gl_RayFlagsTerminateOnFirstHitEXT*/;
		const uint 		cullMask           	= 0xFF;
		const uint 		sbtRecordOffset    	= 1;
		const uint 		sbtRecordStride    	= 0;
		const uint 		missIndex          	= 1;
		const float 	Tmin              	= 0.001f;
		const float 	Tmax              	= 10000.0f;
		const int 		payload       		= 1;

		//Send Shadow Ray
		traceRayEXT(u_TLAS, rayFlags, cullMask, sbtRecordOffset, sbtRecordStride, missIndex, origin.xyz, Tmin, direction.xyz, Tmax, payload);

		float shadow 		= step(s_ShadowPayload.Distance, Tmin);

		Scatter_f 	= dirLightSample.Scatter_f;
		L_d 		= shadow * dirLightSample.L_d;
	}
}

void main()
{
    //Calculate Screen Coords
	const ivec2 pixelCoords = ivec2(gl_LaunchIDEXT.xy);
	const vec2 pixelCenter = vec2(pixelCoords) + vec2(0.5f);
	vec2 screenTexCoord = (pixelCenter / vec2(gl_LaunchSizeEXT.xy));
	vec2 d = screenTexCoord * 2.0 - 1.0;

	//Sample GBuffer
	vec4 sampledNormalMetallicRoughness = texture(u_NormalMetallicRoughness, screenTexCoord);

    //Skybox
	if (dot(sampledNormalMetallicRoughness, sampledNormalMetallicRoughness) < EPSILON)
	{
		imageStore(u_DirectRadiance, 	pixelCoords, vec4(0.529f, 0.808, 0.922f, 	1.0f));
		imageStore(u_IndirectRadiance, 	pixelCoords, vec4(0.0f, 0.0f, 0.0f, 1.0f));
		imageStore(u_DirectAlbedo, 		pixelCoords, vec4(1.0f));
		imageStore(u_IndirectAlbedo, 	pixelCoords, vec4(1.0f));
		return;
	}

	SLightsBuffer lightsBuffer			= u_LightsBuffer.val;
    SPerFrameBuffer perFrameBuffer   	= u_PerFrameBuffer.val;

	//Sample GBuffer
	vec4 sampledAlbedoAO    		= texture(u_AlbedoAO, screenTexCoord);
	float sampledDepth      		= texture(u_DepthStencil, screenTexCoord).r;
	//vec4 sampledDirectRadiance 		= imageLoad(u_DirectRadiance, pixelCoords);
	//vec4 sampledIndirectRadiance 	= imageLoad(u_IndirectRadiance, pixelCoords);

	//Unpack GBuffer
	vec3 albedo         = sampledAlbedoAO.rgb;
    vec3 normal         = CalculateNormal(sampledNormalMetallicRoughness);
    float ao            = sampledAlbedoAO.a;
    float metallic      = abs(sampledNormalMetallicRoughness.b);
    float roughness     = max(EPSILON, abs(sampledNormalMetallicRoughness.a));
	bool emissive		= sampledNormalMetallicRoughness.b > 0.0f;

	//Define local Coordinate System
	vec3 tangent 	= vec3(0.0f);
	vec3 bitangent 	= vec3(0.0f);
	CreateCoordinateSystem(normal, tangent, bitangent);

	//Create Transformation Matrices
	mat3 localToWorld = mat3(tangent, bitangent, normal);
	mat3 worldToLocal = transpose(localToWorld);

	//Define Constants
	SPositions positions            = CalculatePositionsFromDepth(screenTexCoord, sampledDepth, perFrameBuffer.ProjectionInv, perFrameBuffer.ViewInv);
    SRayDirections rayDirections   	= CalculateRayDirections(positions.WorldPos, normal, perFrameBuffer.Position.xyz, perFrameBuffer.ViewInv);	
	float NdotV     				= abs(dot(normal, rayDirections.ViewDir)); //Same as cosTheta
	vec3 world_w_o 					= rayDirections.ViewDir;
	vec3 w_o						= worldToLocal * world_w_o;

	//Define Sample Variables
	uint randomSeed = perFrameBuffer.RandomSeed + pixelCoords.x * gl_LaunchSizeEXT.x + pixelCoords.y;
    uvec3 randomSeedPoint = uvec3(randomSeed, randomSeed >> 10, randomSeed >> 20);
	ivec3 blueNoiseSize = textureSize(u_BlueNoiseLUT, 0);
	
	// vec3 L_o_Direct 		= sampledDirectRadiance.rgb;
	// vec3 L_o_Indirect 		= sampledIndirectRadiance.rgb;
	// float accumulation		= sampledDirectRadiance.a;

	// if (perFrameBuffer.PrevView != perFrameBuffer.View)
	// {
	// 	L_o_Direct			= vec3(0.0f);
	// 	L_o_Indirect		= vec3(0.0f);
	// 	accumulation		= 0.0f;
	// }

	vec3 L_o_Direct 		= vec3(0.0f);
	vec3 L_o_Indirect 		= vec3(0.0f);
	vec3 Albedo_Direct 		= vec3(1.0f);
	vec3 Albedo_Indirect 	= vec3(1.0f);

	s_RadiancePayload.ScatterPosition	= positions.WorldPos + normal * RAY_NORMAL_OFFSET;
	s_RadiancePayload.Albedo			= albedo;
	s_RadiancePayload.Metallic			= metallic;
	s_RadiancePayload.Roughness			= roughness;
	s_RadiancePayload.Emissive			= emissive;
	s_RadiancePayload.Distance			= 1.0f;
	s_RadiancePayload.LocalToWorld 		= localToWorld;

	const int maxBounces 				= 4; //Includes the first "bounce" (more like surface interaction) on the camera
	const int russianRouletteStart		= 3;
	const int numSamplesPerFrame		= maxBounces * 4;

	const float MIN_ROUGHNESS_DELTA_DISTRIBUTION = EPSILON * 2.0f;

	vec3 throughput  					= vec3(1.0f);

	for (int b = 0; b < maxBounces; b++)
	{
		bool stop 	= false;
		vec3 L 		= vec3(0.0f);

		int baseB 	= b * 3;
		vec4 u = vec4( 	GenerateSample(baseB + 0, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
				 		GenerateSample(baseB + 1, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
				 		GenerateSample(baseB + 2, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
						GenerateSample(baseB + 3, randomSeedPoint, numSamplesPerFrame, blueNoiseSize));
		bool isSpecular = s_RadiancePayload.Roughness < MIN_ROUGHNESS_DELTA_DISTRIBUTION;

		//Emissive Surface
		if (s_RadiancePayload.Emissive)
		{
			//L += s_RadiancePayload.Albedo * 100.0f;

			//accumulation 	+= 1.0f;
		}

		//Direct Lighting (next event estimation)
		if (!isSpecular) //Since specular distributions are described by a delta distribution, lights have 0 probability of contributing to this reflection
		{
			vec3 L_d 		= vec3(0.0f);
			vec3 Scatter_f 	= vec3(0.0f);
			SampleLights(w_o, worldToLocal, L_d, Scatter_f);

			if (b == 0)
			{
				L				+= L_d;
				Albedo_Direct 	= Scatter_f;
			}
			// else if (b == 1)
			// {
			// 	vec3 difTerm				= max(vec3(5e-3f), albedo * INV_PI);

			// 	vec3 F_0    = vec3(0.04f);
			// 	F_0	        = mix(F_0, albedo, metallic);

			// 	float diffuseLuminance      = max(0.01f, luminance(albedo));
			// 	float specularLuminance     = max(0.01f, luminance(F_0));
			// 	float probToSampleDiffuse   = diffuseLuminance / (diffuseLuminance + specularLuminance);
			// 	bool sampleDiffuse          = GenerateSample(2, randomSeedPoint, numSamplesPerFrame, blueNoiseSize) < probToSampleDiffuse;

			// 	vec3 difFinal				= vec3(1.0f) / probToSampleDiffuse;
			// 	vec3 ggxFinal				= throughput / (difTerm * (1.0f - probToSampleDiffuse));
			// 	vec3 brdfFinal				= sampleDiffuse ? difFinal : ggxFinal;

			// 	L				+= brdfFinal * Scatter_f * L_d;
			// 	Albedo_Indirect =  difTerm;
			// }
			else
			{
				L				+= throughput * Scatter_f * L_d;
			}
		}

		//Write to Direct or Indirect L_o
		if (b == 0) //b == 0 is is emitted + direct lighting
		{
			L_o_Direct 		+= L;
		}
		else
		{
			L_o_Indirect 	+= L;
		}

		//Prepare Next Surface Interaction (Bounce)
		{
			//Sample the BRDF
			SReflection reflection = Sample_f(w_o, s_RadiancePayload.Albedo,  s_RadiancePayload.Metallic, s_RadiancePayload.Roughness, u.xyz);

			vec3 reflectionDir = s_RadiancePayload.LocalToWorld * reflection.w_i;

			if (reflection.PDF > 0.0f)
			{
				throughput			*= reflection.f * reflection.CosTheta / reflection.PDF;
				world_w_o			= -reflectionDir;

				//Define Reflection Ray Parameters
				const vec3 		origin 				= s_RadiancePayload.ScatterPosition;
				const vec3 		direction			= reflectionDir;
				const uint 		rayFlags           	= gl_RayFlagsOpaqueEXT/* | gl_RayFlagsTerminateOnFirstHitEXT*/;
				const uint 		cullMask           	= 0xFF;
				const uint 		sbtRecordOffset    	= 0;
				const uint 		sbtRecordStride    	= 0;
				const uint 		missIndex          	= 0;
				const float 	Tmin              	= 0.001f;
				const float 	Tmax              	= 10000.0f;
				const int 		payload       		= 0;
				
				//Send Reflection Ray
				traceRayEXT(u_TLAS, rayFlags, cullMask, sbtRecordOffset, sbtRecordStride, missIndex, origin.xyz, Tmin, direction.xyz, Tmax, payload);
		
				if (s_RadiancePayload.Distance <= Tmin)
				{
					stop = true;
				}

				worldToLocal 	= transpose(s_RadiancePayload.LocalToWorld);
				w_o				= worldToLocal * world_w_o;
			}
			else
			{
				s_RadiancePayload.ScatterPosition	= vec3(0.0f);
				s_RadiancePayload.Albedo			= vec3(0.0f);
				s_RadiancePayload.Metallic			= 0.0f;
				s_RadiancePayload.Roughness			= 0.0f;
				s_RadiancePayload.Distance			= 0.0f;
				s_RadiancePayload.LocalToWorld 		= mat3(1.0f);

				//if (dot(throughput, throughput) < EPSILON)
					//throughput = reflection.f * reflection.CosTheta;

				stop = true;
			}
		}

		//Russian Roulette
		{
			if (b > russianRouletteStart)
			{
				float p = max(throughput.r, max(throughput.g, throughput.b));

				if (u.w >= p)
				{
					stop = true;
				}

				throughput *= 1.0f / p;
			}
		}

		if (stop) break;
	}

	//accumulation 	+= 1.0f;

	//Direct Lighting (next event estimation)
	// if (s_RadiancePayload.Distance > 0.0f && s_RadiancePayload.Roughness > MIN_ROUGHNESS_DELTA_DITRIBUTION_LIGHTS)
	// {
	// 	L_o 			+= SampleLights(w_o, worldToLocal, throughput);
	// 	accumulation 	+= 1.0f;
	// }

	imageStore(u_DirectRadiance, 	pixelCoords, vec4(L_o_Direct, 	1.0f));
	imageStore(u_IndirectRadiance, 	pixelCoords, vec4(L_o_Indirect, 1.0f));
	imageStore(u_DirectAlbedo, 		pixelCoords, vec4(Albedo_Direct, 1.0f));
	imageStore(u_IndirectAlbedo, 	pixelCoords, vec4(Albedo_Indirect, 1.0f));
}