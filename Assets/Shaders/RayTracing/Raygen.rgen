#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : enable
//#extension GL_EXT_debug_printf : enable

#include "../Helpers.glsl"
#include "../Defines.glsl"
#include "RayTracingInclude.glsl"

layout(location = 0) rayPayloadEXT SPrimaryPayload s_PrimaryPayload;

void GenerateCameraRay(in vec2 d, out vec3 origin, out vec3 direction)
{
    SPerFrameBuffer perFrameBuffer = u_PerFrameBuffer.val;
    origin      = (perFrameBuffer.ViewInv * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    vec4 target = perFrameBuffer.ProjectionInv * vec4(d.x, d.y, 1.0f, 1.0f);
    direction   = (perFrameBuffer.ViewInv * vec4(normalize(target.xyz), 0.0f)).xyz;
}

void main()
{
    //Calculate Screen Coords
	const ivec2 pixelCoords = ivec2(gl_LaunchIDEXT.xy);
	const vec2 pixelCenter  = vec2(pixelCoords) + vec2(0.5f);
	vec2 screenTexCoord     = (pixelCenter / vec2(gl_LaunchSizeEXT.xy));
	vec2 d                  = screenTexCoord * 2.0f - 1.0f;

    //Sample required
    vec4 aoRoughMetalValid  = imageLoad(u_GBufferAORoughMetalValid, pixelCoords);
    float roughness         = aoRoughMetalValid.g;
    float valid             = aoRoughMetalValid.a;

    //Return early if roughness is non-zero
    if (roughness > 0.0f || valid < 1.0f)
        return;

    //Sample GBuffer
    vec3 worldPosition  = imageLoad(u_GBufferPosition, pixelCoords).xyz;
    vec3 normal         = normalize(OctToDir(imageLoad(u_GBufferCompactNormal, pixelCoords).xy));

    //Setup convenience variables
    SPerFrameBuffer perFrameBuffer              = u_PerFrameBuffer.val;

    SRayDirections rayDirections = CalculateRayDirections(worldPosition, normal, perFrameBuffer.CameraPosition.xyz);
    
    //Setup Ray Tracing Parameters
    vec3            origin              = worldPosition + normal * RAY_NORMAL_OFFSET;
    vec3            direction           = rayDirections.ReflDir;
    const uint 		rayFlags           	= gl_RayFlagsOpaqueEXT/* | gl_RayFlagsTerminateOnFirstHitEXT*/;
    const uint 		cullMask           	= 0xFF;
    const uint 		sbtRecordOffset    	= 0;
    const uint 		sbtRecordStride    	= 0;
    const uint 		missIndex          	= 0;
    const float 	Tmin              	= 0.001f;
    const float 	Tmax              	= 10000.0f;
    const int 		payload       		= 0;

    //Send Ray
    traceRayEXT(u_TLAS, rayFlags, cullMask, sbtRecordOffset, sbtRecordStride, missIndex, origin, Tmin, direction, Tmax, payload);

    if (s_PrimaryPayload.Distance > 0.0f)
    {
        imageStore(u_GBufferPosition,           pixelCoords, vec4(s_PrimaryPayload.HitPosition, 1.0f));
        imageStore(u_GBufferAlbedo,             pixelCoords, vec4(s_PrimaryPayload.Albedo, 1.0f));
        imageStore(u_GBufferAORoughMetalValid,  pixelCoords, vec4(s_PrimaryPayload.AO, s_PrimaryPayload.Roughness, s_PrimaryPayload.Metallic, 1.0f));
        imageStore(u_GBufferCompactNormal,      pixelCoords, vec4(DirToOct(s_PrimaryPayload.Normal), 1.0f, 1.0f));
    }
}