#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : enable
//#extension GL_EXT_debug_printf : enable

#include "RayTracingInclude.glsl"
#include "../Reflections.glsl"
#include "../Helpers.glsl"
#include "../Defines.glsl"
#include "BxDF.glsl"

#define MAX_BOUNCES 8

layout(location = 0) rayPayloadEXT SPrimaryPayload s_PrimaryPayload;

/*
* Variable name explanation:
* p - used for point
* w - used for directions, directions are often thought of as infinitesimal parts of a solid angle we integrate over which we call Omega, therefore most directions are small omega (Omega') (see PRT)
* l - radiance
* _n suffix - normal
* _o suffix - out vector
* _i suffix - in vector
* _h suffix - halfway (microfacet normal) vector
* _(*)w suffix - world space
* _(*)s suffix - surface space
* _(*)l suffix - light space (or light related)
* d - distances
* u - sample variates
*/

/*
* p_w 		- Point to shade 
* w_nw 		- Normal direction
* w_ow  	- direction from p_w -> prev_p_w
* n_dot_o 	- max(dot(w_nw, w_ow), 0.0f)
* d			- ||p_w - prev_p_w||
* albedo	- albedo or diffuse color
* ao		- ambient occlusion
* roughness
* metallic
*/
vec3 ShadePoint(vec3 p_w, vec3 w_nw, vec3 w_ow, float n_dot_o, float d, vec3 albedo, float ao, float roughness, float metallic, vec3 F0)
{
		vec3 ambient 	= vec3(0.0f);
		vec3 l_o 		= vec3(0.0f);

		SLightsBuffer lightBuffer = b_LightsBuffer.val;

		// Directional Light
		{
			vec3 w_iw		= normalize(lightBuffer.DirL_Direction);
			vec3 w_hw		= normalize(w_ow + w_iw);

			float n_dot_i 	= max(dot(w_nw, w_iw), 0.0f);

			vec4 p_l 				= lightBuffer.DirL_ProjView * vec4(p_w, 1.0f);
			float shadow 			= DirShadowDepthTest(p_l, w_nw, w_iw, u_DirLShadowMap);
			vec3 outgoingRadiance	= lightBuffer.DirL_ColorIntensity.rgb * lightBuffer.DirL_ColorIntensity.a;
			vec3 incomingRadiance	= outgoingRadiance * (1.0f - shadow);

			float NDF   = Distribution(w_nw, w_hw, roughness);
			float G     = Geometry(w_nw, w_ow, w_iw, roughness);
			vec3 F      = Fresnel(F0, max(dot(w_ow, w_hw), 0.0f));

			vec3 k_s = F;
			vec3 k_d = vec3(1.0f) - k_s;

			k_d *= 1.0 - metallic;

			vec3 nominator      = NDF * G * F;
			float denominator   = 4.0f * n_dot_o * n_dot_i;
			vec3 f_Specular 	= nominator / max(denominator, 0.001f);
			vec3 f_Diffuse 		= k_d * albedo * INV_PI;

			l_o += (f_Diffuse + f_Specular) * incomingRadiance * n_dot_i;
		}

		//Point Light Loop
		for (uint i = 0; i < uint(lightBuffer.PointLightCount); i++)
		{
			SPointLight light = b_LightsBuffer.pointLights[i];

			vec3 w_iw 	= (light.Position - p_w);
			float d_l 	= length(w_iw);	
			w_iw		= normalize(w_iw);
			vec3 w_hw	= normalize(w_ow + w_iw);
			
			float n_dot_i = max(dot(w_nw, w_iw), 0.0f);

			float shadow 			= PointShadowDepthTest(p_w, light.Position, d, w_nw, u_PointLShadowMap[light.TextureIndex], light.FarPlane);
			float attenuation		= max(1.0f / (d_l * d_l), 0.001f);
			vec3 outgoingRadiance	= light.ColorIntensity.rgb * light.ColorIntensity.a;
			vec3 incomingRadiance	= outgoingRadiance * attenuation * (1.0f - shadow);
		
			float NDF   = Distribution(w_nw, w_hw, roughness);
			float G     = Geometry(w_nw, w_ow, w_iw, roughness);
			vec3 F      = Fresnel(F0, max(dot(w_ow, w_hw), 0.0f));

			vec3 k_s = F;
			vec3 k_d = vec3(1.0f) - k_s;

			k_d *= 1.0 - metallic;

			vec3 nominator      = NDF * G * F;
			float denominator   = 4.0f * n_dot_o * n_dot_i;
			vec3 f_Specular 	= nominator / max(denominator, 0.001f);
			vec3 f_Diffuse 		= k_d * albedo * INV_PI;

			l_o += (f_Diffuse + f_Specular) * incomingRadiance * n_dot_i;
		}

		//IBL
		{
			vec3 F_IBL		= FresnelRoughness(F0, n_dot_o, roughness);
			vec3 k_s_IBL	= F_IBL;
			vec3 k_d_IBL	= 1.0f - k_s_IBL;
			k_d_IBL			*= 1.0f - metallic;
		
			vec3 irradiance		= texture(u_GlobalDiffuseProbe, w_nw).rgb;
			vec3 IBL_Diffuse	= irradiance * albedo * k_d_IBL;
		
			const int numberOfMips	= textureQueryLevels(u_GlobalSpecularProbe);
			vec3 w_iw_inv			= reflect(-w_ow, w_nw);
			vec3 prefiltered		= textureLod(u_GlobalSpecularProbe, w_iw_inv, roughness * float(numberOfMips)).rgb;
			vec2 integrationBRDF	= textureLod(u_IntegrationLUT, vec2(n_dot_o, roughness), 0).rg;
			vec3 IBL_Specular		= prefiltered * (F_IBL * integrationBRDF.x + integrationBRDF.y);
		
			ambient = (IBL_Diffuse + IBL_Specular) * ao;
		}

		return ambient + l_o;
}

float GenerateSample(uint index, uvec3 p, uint numSamplesPerFrame, uvec3 blueNoiseSize)
{
	p.z = (p.z * numSamplesPerFrame + index);
	p &= (blueNoiseSize - 1);

	return min(texelFetch(u_BlueNoiseLUTs, ivec3(p), 0).r, 0.9999999999999f);
}

void main()
{
	//Calculate Screen Coords
	const ivec2 pixelCoords = ivec2(gl_LaunchIDEXT.xy);
	const vec2 pixelCenter  = vec2(pixelCoords) + vec2(0.5f);
	vec2 screenTexCoord     = (pixelCenter / vec2(gl_LaunchSizeEXT.xy));

	//Sample required
	vec4 aoRoughMetalValid  = texelFetch(u_GBufferAORoughMetalValid, pixelCoords, 0);
	float roughness         = aoRoughMetalValid.g;
	float valid             = aoRoughMetalValid.a;

	if (valid < 1.0f || roughness > REFLECTION_REJECT_THRESHOLD)
	{
		imageStore(u_Reflections, pixelCoords, vec4(0.0f));
		imageStore(u_BRDF_PDF, pixelCoords, vec4(0.0f));
		return;
	}

	//Setup convenience variables
	SPerFrameBuffer perFrameBuffer  = u_PerFrameBuffer.val;
	float metallic     	= aoRoughMetalValid.b;
	float ao       		= aoRoughMetalValid.r;

	//Calculate World Position
	float sampledDepth      = texelFetch(u_GBufferDepthStencil, pixelCoords, 0).r;
	SPositions positions    = CalculatePositionsFromDepth(screenTexCoord, sampledDepth, perFrameBuffer.ProjectionInv, perFrameBuffer.ViewInv);

	//Sample GBuffer
	vec3 normal             = UnpackNormal(texelFetch(u_GBufferCompactNormal, pixelCoords, 0).xyz);

	//Initialize required parameters for first bounce
	s_PrimaryPayload.HitPosition	= positions.WorldPos;
	s_PrimaryPayload.Normal		    = normal;
	s_PrimaryPayload.Roughness		= roughness;
	s_PrimaryPayload.Metallic		= metallic;
	s_PrimaryPayload.AO				= ao;
	s_PrimaryPayload.Distance       = 1.0f;

	vec3 w_ow_start = normalize(perFrameBuffer.CameraPosition.xyz - s_PrimaryPayload.HitPosition);

	vec3 reflDir;
	vec3 throughput;

#if !GLOSSY_REFLECTIONS_ENABLED
	{
		//Calculate a mirror reflection direction
		reflDir = reflect(-w_ow_start, s_PrimaryPayload.Normal);
		throughput = vec3(1.0f);
	}
#else
	//Define Sample Variables
	const uint randomSeed 			= perFrameBuffer.RandomSeed + pixelCoords.x * gl_LaunchSizeEXT.x + pixelCoords.y;
	const uvec3 randomSeedPoint 	= uvec3(randomSeed, randomSeed >> 10, randomSeed >> 20);
	const ivec3 blueNoiseSize 		= textureSize(u_BlueNoiseLUTs, 0);	
	const uint numSamplesPerBounce	= 4;
	const uint numSamplesPerFrame 	= (MAX_BOUNCES + 1) * numSamplesPerBounce;

	s_PrimaryPayload.Albedo = texelFetch(u_GBufferAlbedo, pixelCoords, 0).rgb;
	
	float n_dot_o_start = max(dot(s_PrimaryPayload.Normal, w_ow_start), 0.001f);
	vec3 F0_start 		= F0(s_PrimaryPayload.Albedo, s_PrimaryPayload.Metallic);
	
	vec4 u_Surface_BRDF = vec4( 	GenerateSample(0, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
									GenerateSample(1, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
									GenerateSample(2, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
									GenerateSample(3, randomSeedPoint, numSamplesPerFrame, blueNoiseSize)); 

	SReflectionDesc reflectionDescStart = Sample_f(
		w_ow_start, 
		s_PrimaryPayload.Normal, 
		n_dot_o_start, 
		s_PrimaryPayload.Albedo,
		s_PrimaryPayload.Roughness, 
		s_PrimaryPayload.Metallic,
		F0_start, 
		u_Surface_BRDF);

	imageStore(u_BRDF_PDF, pixelCoords, vec4(reflectionDescStart.f_Specular * n_dot_o_start, reflectionDescStart.PDF_Specular));

	reflDir = reflectionDescStart.w_iw;

	//Initialize Glossy Variables
	throughput = reflectionDescStart.f * n_dot_o_start / reflectionDescStart.PDF;
	vec3 l_o = vec3(0.0f);
	bool hitGlossySurface = false;
	if (s_PrimaryPayload.Roughness > 0.0f)
	{
		//Här är problemet, denna borde ej shadeas med IBL
		/*l_o += ShadePoint( 
			s_PrimaryPayload.HitPosition,
			s_PrimaryPayload.Normal,
			w_ow_start,
			n_dot_o_start,
			s_PrimaryPayload.Distance,
			s_PrimaryPayload.Albedo,
			s_PrimaryPayload.AO,
			s_PrimaryPayload.Roughness,
			s_PrimaryPayload.Metallic,
			F0_start);*/

		hitGlossySurface = true;
	}
#endif

	bool shadeOutput     = false;
	
	const uint 		rayFlags           	= gl_RayFlagsNoneEXT;//gl_RayFlagsOpaqueEXT/* | gl_RayFlagsTerminateOnFirstHitEXT*/;
	const uint 		cullMask           	= 0xFF;
	const uint 		sbtRecordOffset    	= 0;
	const uint 		sbtRecordStride    	= 0;
	const uint 		missIndex          	= 0;
	const float 	Tmin              	= 0.001f;
	const float 	Tmax              	= 10000.0f;
	const int 		payload       		= 0;

	uint b = 0;
	
	for (; b < MAX_BOUNCES; b++)
	{
		shadeOutput = true;
		
		//Setup Ray Tracing Parameters
		vec3 origin    = s_PrimaryPayload.HitPosition + s_PrimaryPayload.Normal * RAY_NORMAL_OFFSET;
		vec3 direction = reflDir;

		//Send Ray
		traceRayEXT(u_TLAS, rayFlags, cullMask, sbtRecordOffset, sbtRecordStride, missIndex, origin, Tmin, direction, Tmax, payload);

		//Break if we missed geometry (we don't want to reflect of the skybox)
		if (s_PrimaryPayload.Distance < EPSILON)
		{
			shadeOutput = false;
			break;
		}

		bool rejectNextReflection = (s_PrimaryPayload.Roughness > REFLECTION_REJECT_THRESHOLD);

#if !GLOSSY_REFLECTIONS_ENABLED
		//Glossy Disabled, return if not Mirror Reflection, and reflect around normal instead of sampling BRDF
		if (rejectNextReflection)
			break;

		reflDir = reflect(reflDir,  s_PrimaryPayload.Normal);
#else

		uint baseSampleIndex = b * numSamplesPerBounce;
		u_Surface_BRDF = vec4( 	GenerateSample(baseSampleIndex + 0, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
								GenerateSample(baseSampleIndex + 1, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
								GenerateSample(baseSampleIndex + 2, randomSeedPoint, numSamplesPerFrame, blueNoiseSize),
								GenerateSample(baseSampleIndex + 3, randomSeedPoint, numSamplesPerFrame, blueNoiseSize)); 

		vec3 w_ow 		= -reflDir;
		vec3 w_nw 		= s_PrimaryPayload.Normal;
		float n_dot_o 	= max(dot(w_nw, w_ow), 0.001f);
		vec3 F0 		= F0(s_PrimaryPayload.Albedo, s_PrimaryPayload.Metallic);

		SReflectionDesc reflectionDesc = Sample_f(
			w_ow, 
			w_nw, 
			n_dot_o, 
			s_PrimaryPayload.Albedo,
			s_PrimaryPayload.Roughness, 
			s_PrimaryPayload.Metallic,
			F0, 
			u_Surface_BRDF);

		reflDir = reflectionDesc.w_iw;

		//Update l_o
		if (s_PrimaryPayload.Roughness > 0.0f)
		{
			l_o += throughput * ShadePoint(
				s_PrimaryPayload.HitPosition,
				s_PrimaryPayload.Normal,
				w_ow,
				n_dot_o,
				s_PrimaryPayload.Distance, 
				s_PrimaryPayload.Albedo, 
				s_PrimaryPayload.AO, 
				s_PrimaryPayload.Roughness, 
				s_PrimaryPayload.Metallic,
				F0);

			//We brake if the surface we hit is rough, we only allow this for first bounce
			break;
		}

		//Update Throughput
		throughput *= reflectionDesc.f * n_dot_o / reflectionDesc.PDF;
#endif

	}

	vec3 colorHDR;
	if (shadeOutput)
	{
#if !GLOSSY_REFLECTIONS_ENABLED
		float n_dot_o = max(dot(s_PrimaryPayload.Normal, -reflDir), 0.0f);

		vec3 F0 = F0(s_PrimaryPayload.Albedo, s_PrimaryPayload.Metallic);

		colorHDR = ShadePoint(
			s_PrimaryPayload.HitPosition,
			s_PrimaryPayload.Normal,
			-reflDir,
			n_dot_o,
			s_PrimaryPayload.Distance, 
			s_PrimaryPayload.Albedo, 
			s_PrimaryPayload.AO, 
			s_PrimaryPayload.Roughness, 
			s_PrimaryPayload.Metallic,
			F0);
#else
		colorHDR = l_o;
#endif

	}
	else
	{
		colorHDR = throughput * s_PrimaryPayload.Albedo;
	}

	//Fake energy loss on mirror bounce
	float bounceDarkening = float(MAX_BOUNCES - b) / float(MAX_BOUNCES);
	colorHDR *= bounceDarkening;

	//Reinhard Tone-Mapping
	vec3 colorLDR = colorHDR / (colorHDR + vec3(1.0f));

	//Gamma Correction
	vec3 finalColor = pow(colorLDR, vec3(1.0f / GAMMA));

	imageStore(u_Reflections, pixelCoords, vec4(finalColor, 1.0f));
}