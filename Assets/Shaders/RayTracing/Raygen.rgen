#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : enable
//#extension GL_EXT_debug_printf : enable

#include "RayTracingInclude.glsl"
#include "../Helpers.glsl"
#include "../Defines.glsl"
#include "BxDF.glsl"

#define GLOSSY_REFLECTION_ENABLED 0
#if defined(GLOSSY_REFLECTION_ENABLED)
	#define GLOSSY_REJECT_THRESHOLD 0.25f
#endif

layout(location = 0) rayPayloadEXT SPrimaryPayload s_PrimaryPayload;

/*
* Variable name explanation:
* p - used for point
* w - used for directions, directions are often thought of as infinitesimal parts of a surface (solid angle) we integrate over which we call Omega, therefore most directions are small omega (Omega') (see PRT)
* l - radiance
* _n suffix - normal
* _o suffix - out vector
* _i suffix - in vector
* _h suffix - halfway (microfacet normal) vector
* _(*)w suffix - world space
* _(*)s suffix - surface space
* _(*)l suffix - light space (or light related)
* d - distances
* u - sample variates
*/

/*
* p_w 		- Point to shade 
* w_nw 		- Normal direction
* w_ow  	- direction from p_w -> prev_p_w
* n_dot_o 	- max(dot(w_nw, w_ow), 0.0f)
* d			- ||p_w - prev_p_w||
* albedo	- albedo or diffuse color
* ao		- ambient occlusion
* roughness
* metallic
*/
vec3 ShadePoint(vec3 p_w, vec3 w_nw, vec3 w_ow, float n_dot_o, float d, vec3 albedo, float ao, float roughness, float metallic)
{
		vec3 ambient 	= vec3(0.0f);
		vec3 l_o 		= vec3(0.0f);
		
		vec3 F0 = vec3(0.04f);
		F0 = mix(F0, albedo, metallic);

		SLightsBuffer lightBuffer = b_LightsBuffer.val;

		// Directional Light
		{
			vec3 w_iw		= normalize(lightBuffer.DirL_Direction);
			vec3 w_hw		= normalize(w_ow + w_iw);

			float n_dot_i 	= max(dot(w_nw, w_iw), 0.0f);

			vec4 p_l 				= lightBuffer.DirL_ProjView * vec4(p_w, 1.0f);
			float shadow 			= DirShadowDepthTest(p_l, w_nw, w_iw, u_DirLShadowMap);
			vec3 outgoingRadiance	= lightBuffer.DirL_ColorIntensity.rgb * lightBuffer.DirL_ColorIntensity.a;
			vec3 incomingRadiance	= outgoingRadiance * (1.0f - shadow);

			float NDF   = Distribution(w_nw, w_hw, roughness);
			float G     = Geometry(w_nw, w_ow, w_iw, roughness);
			vec3 F      = Fresnel(F0, max(dot(w_ow, w_hw), 0.0f));

			vec3 k_s = F;
			vec3 k_d = vec3(1.0f) - k_s;

			k_d *= 1.0 - metallic;

			vec3 nominator      = NDF * G * F;
			float denominator   = 4.0f * n_dot_o * n_dot_i;
			vec3 f_Specular 	= nominator / max(denominator, 0.001f);
			vec3 f_Diffuse 		= k_d * albedo * INV_PI;

			l_o += (f_Diffuse + f_Specular) * incomingRadiance * n_dot_i;
		}

		//Point Light Loop
		for (uint i = 0; i < uint(lightBuffer.PointLightCount); i++)
		{
			SPointLight light = b_LightsBuffer.pointLights[i];

			vec3 w_iw 	= (light.Position - p_w);
			float d_l 	= length(w_iw);	
			w_iw		= normalize(w_iw);
			vec3 w_hw	= normalize(w_ow + w_iw);
			
			float n_dot_i = max(dot(w_nw, w_iw), 0.0f);

			float shadow 			= PointShadowDepthTest(p_w, light.Position, d, w_nw, u_PointLShadowMap[light.TextureIndex], light.FarPlane);
			float attenuation		= max(1.0f / (d_l * d_l), 0.001f);
			vec3 outgoingRadiance	= light.ColorIntensity.rgb * light.ColorIntensity.a;
			vec3 incomingRadiance	= outgoingRadiance * attenuation * (1.0f - shadow);
		
			float NDF   = Distribution(w_nw, w_hw, roughness);
			float G     = Geometry(w_nw, w_ow, w_iw, roughness);
			vec3 F      = Fresnel(F0, max(dot(w_ow, w_hw), 0.0f));

			vec3 k_s = F;
			vec3 k_d = vec3(1.0f) - k_s;

			k_d *= 1.0 - metallic;

			vec3 nominator      = NDF * G * F;
			float denominator   = 4.0f * n_dot_o * n_dot_i;
			vec3 f_Specular 	= nominator / max(denominator, 0.001f);
			vec3 f_Diffuse 		= k_d * albedo * INV_PI;

			l_o += (f_Diffuse + f_Specular) * incomingRadiance * n_dot_i;
		}

		//IBL
		{
			vec3 F_IBL		= FresnelRoughness(F0, n_dot_o, roughness);
			vec3 k_s_IBL	= F_IBL;
			vec3 k_d_IBL	= 1.0f - k_s_IBL;
			k_d_IBL			*= 1.0f - metallic;
		
			vec3 irradiance		= texture(u_GlobalDiffuseProbe, w_nw).rgb;
			vec3 IBL_Diffuse	= irradiance * albedo * k_d_IBL;
		
			const int numberOfMips	= textureQueryLevels(u_GlobalSpecularProbe);
			vec3 w_iw_inv			= reflect(-w_ow, w_nw);
			vec3 prefiltered		= textureLod(u_GlobalSpecularProbe, w_iw_inv, roughness * float(numberOfMips)).rgb;
			vec2 integrationBRDF	= textureLod(u_IntegrationLUT, vec2(n_dot_o, roughness), 0).rg;
			vec3 IBL_Specular		= prefiltered * (F_IBL * integrationBRDF.x + integrationBRDF.y);
		
			ambient = (IBL_Diffuse + IBL_Specular) * ao;
		}

		return ambient + l_o;
}

void main()
{
	//Calculate Screen Coords
	const ivec2 pixelCoords = ivec2(gl_LaunchIDEXT.xy);
	const vec2 pixelCenter  = vec2(pixelCoords) + vec2(0.5f);
	vec2 screenTexCoord     = (pixelCenter / vec2(gl_LaunchSizeEXT.xy));

	//Sample required
	vec4 aoRoughMetalValid  = texelFetch(u_GBufferAORoughMetalValid, pixelCoords, 0);
	float roughness         = aoRoughMetalValid.g;
	float valid             = aoRoughMetalValid.a;

	if (valid < 1.0f)
		return;

	bool mirrorReflection = (roughness == 0.0f);

#if !GLOSSY_REFLECTION_ENABLED
	if (!mirrorReflection)
		return;
#else
	if (roughness > GLOSSY_REJECT_THRESHOLD)
		return;
#endif

	//Setup convenience variables
	SPerFrameBuffer perFrameBuffer  = u_PerFrameBuffer.val;

	//Calculate World Position
	float sampledDepth      = texelFetch(u_GBufferDepthStencil, pixelCoords, 0).r;
	SPositions positions    = CalculatePositionsFromDepth(screenTexCoord, sampledDepth, perFrameBuffer.ProjectionInv, perFrameBuffer.ViewInv);

	//Sample GBuffer
	vec3 normal             = UnpackNormal(texelFetch(u_GBufferCompactNormal, pixelCoords, 0).xyz);

	//Initialize required parameters for first bounce
	s_PrimaryPayload.HitPosition	= positions.WorldPos;
	s_PrimaryPayload.Normal		    = normal;
	s_PrimaryPayload.Roughness		= roughness;
	s_PrimaryPayload.Distance       = 1.0f;

	//Calculate a mirror reflection direction
	SRayDirections rayDirections = CalculateRayDirections(s_PrimaryPayload.HitPosition, normal, perFrameBuffer.CameraPosition.xyz);
	vec3 reflDir = rayDirections.ReflDir;

	const uint MAX_BOUNCES = 8;
	bool shadeOutput     = false;

	const uint 		rayFlags           	= gl_RayFlagsNoneEXT;//gl_RayFlagsOpaqueEXT/* | gl_RayFlagsTerminateOnFirstHitEXT*/;
	const uint 		cullMask           	= 0xFF;
	const uint 		sbtRecordOffset    	= 0;
	const uint 		sbtRecordStride    	= 0;
	const uint 		missIndex          	= 0;
	const float 	Tmin              	= 0.001f;
	const float 	Tmax              	= 10000.0f;
	const int 		payload       		= 0;

	uint b = 0;
	vec3 throughput = vec3(1.0f);

	for (; b < MAX_BOUNCES; b++)
	{
		shadeOutput = true;
		
		//Setup Ray Tracing Parameters
		vec3 origin    = s_PrimaryPayload.HitPosition + s_PrimaryPayload.Normal * RAY_NORMAL_OFFSET;
		vec3 direction = reflDir;

		//Send Ray
		traceRayEXT(u_TLAS, rayFlags, cullMask, sbtRecordOffset, sbtRecordStride, missIndex, origin, Tmin, direction, Tmax, payload);

		//Break if we missed geometry (we don't want to reflect of the skybox)
		if (s_PrimaryPayload.Distance < EPSILON)
		{
			shadeOutput = false;
			break;
		}

		mirrorReflection = (s_PrimaryPayload.Roughness == 0.0f);

#if !GLOSSY_REFLECTION_ENABLED
		//Glossy Disabled, return if not Mirror Reflection, and reflect around normal instead of sampling BRDF

		if (!mirrorReflection)
			break;

		reflDir = reflect(reflDir,  s_PrimaryPayload.Normal);
#else
		if (s_PrimaryPayload.Roughness > GLOSSY_REJECT_THRESHOLD)
			break;

		
#endif

	}

	//We don't want to shade if we reached max bounces, our fake energy loss will make the color black anyway
	if (b == MAX_BOUNCES)
	{
		imageStore(u_IntermediateOutputImage, pixelCoords, vec4(0.0f));
	}
	else
	{
		vec3 colorHDR;
		if (shadeOutput)
		{
			//Fake energy loss on mirror bounce
			float bounceDarkening = float(MAX_BOUNCES - b) / float(MAX_BOUNCES);

			float n_dot_o = max(dot(s_PrimaryPayload.Normal, -reflDir), 0.0f);

			colorHDR = bounceDarkening * ShadePoint(
				s_PrimaryPayload.HitPosition,
				s_PrimaryPayload.Normal,
				-reflDir,
				n_dot_o,
				s_PrimaryPayload.Distance, 
				s_PrimaryPayload.Albedo, 
				s_PrimaryPayload.AO, 
				s_PrimaryPayload.Roughness, 
				s_PrimaryPayload.Metallic);
		}
		else
		{
			colorHDR = s_PrimaryPayload.Albedo;
		}

		float luminance = CalculateLuminance(colorHDR);

		//Reinhard Tone-Mapping
		vec3 colorLDR = colorHDR / (colorHDR + vec3(1.0f));

		//Gamma Correction
		vec3 finalColor = pow(colorLDR, vec3(1.0f / GAMMA));

		imageStore(u_IntermediateOutputImage, pixelCoords, vec4(finalColor, luminance));
	}
}