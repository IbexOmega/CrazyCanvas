#version 460
#extension GL_GOOGLE_include_directive : enable

#define NO_BUFFERS

#include "../Defines.glsl"
#include "../Helpers.glsl"
#include "../Reflections.glsl"

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0,	set = TEXTURE_SET_INDEX) uniform sampler2D u_Reflections;
layout(binding = 1,	set = TEXTURE_SET_INDEX) uniform sampler2D u_BRDF_PDF;
layout(binding = 2,	set = TEXTURE_SET_INDEX, rgba16f) restrict uniform image2D u_DenoisedReflections;
layout(binding = 3, set = TEXTURE_SET_INDEX) uniform sampler2D u_GBufferCompactNormal;
layout(binding = 4, set = TEXTURE_SET_INDEX) uniform sampler2D u_GBufferVelocity;
layout(binding = 5, set = TEXTURE_SET_INDEX) uniform sampler2D u_GBufferLinearZ;
layout(binding = 6, set = TEXTURE_SET_INDEX) uniform sampler2D u_GBufferPrevLinearZ;

float ValidSample(ivec2 iImageDim, ivec2 reprojCoord, float Z, float prevZ, float fwidthZ, vec3 normal, vec3 reprojNormal)
{
    bool result = true;

    // check whether reprojected pixel is inside of the screen
    result = result && (!any(lessThan(reprojCoord, ivec2(0, 0))) && !any(greaterThan(reprojCoord, iImageDim - ivec2(1, 1))));
    // check if deviation of depths is acceptable
    result = result && !((abs(prevZ - Z) / (fwidthZ + 1e-4f)) > 2.0f);
    // check normals for compatibility
    result = result && !(dot(normal, reprojNormal) < 0.95f);

    return float(result);
}

void main()
{
    ivec2 BLUR_IMAGE_SIZE = imageSize(u_DenoisedReflections);
    int BLUR_IMAGE_TOTAL_NUM_PIXELS = BLUR_IMAGE_SIZE.x * BLUR_IMAGE_SIZE.y;

    if (gl_GlobalInvocationID.x >= BLUR_IMAGE_TOTAL_NUM_PIXELS) 
        return;

    ivec2 p = ivec2(gl_GlobalInvocationID.x % BLUR_IMAGE_SIZE.x, gl_GlobalInvocationID.x / BLUR_IMAGE_SIZE.x);

    vec4 current_FinalColor_Valid = texelFetch(u_Reflections, p, 0);
    float validSample = current_FinalColor_Valid.a;

    //Sample GBuffer
	vec3 currentNormal  = UnpackNormal(texelFetch(u_GBufferCompactNormal, p, 0).xyz);
    vec2 velocity       = texelFetch(u_GBufferVelocity, p, 0).xy;

#if SPATIAL_BRDF_DENOISING_ENABLED 
    vec3 weightSum = vec3(0.0f);

    if (validSample > 0.0f)
    {
        vec4 orig_brdf_pdf = texelFetch(u_BRDF_PDF, p, 0);

        for (int y = -2; y <= 2; y++)
        {
            for (int x = -2; x <= 2; x++)
            {
                //Id both 0, we are at center
                if (x == 0 && y == 0)
                {
                    vec3 weight = orig_brdf_pdf.rgb / orig_brdf_pdf.a;
                    current_FinalColor_Valid.rgb += current_FinalColor_Valid.rgb * weight;
                    weightSum += weight;
                }
                else
                {
                    ivec2 pp = ivec2(p.x + x, p.y + y);

                    if (pp.x >= 0 && pp.x < BLUR_IMAGE_SIZE.x && pp.y >= 0 && pp.y < BLUR_IMAGE_SIZE.y)
                    {
                        vec4 local_brdf_pdf = texelFetch(u_BRDF_PDF, pp, 0);

                        vec3 weight = local_brdf_pdf.rgb / orig_brdf_pdf.a;
                        current_FinalColor_Valid.rgb += texelFetch(u_Reflections, pp, 0).rgb * weight;
                        weightSum += weight;
                    }
                }
            }
        }

        current_FinalColor_Valid.rgb /= max(weightSum, vec3(1.0f));
    }
#endif
    
    float historyLength = 0.0f;

#if TEMPORAL_REUSE_ENABLED
    ivec2 reprojP        = p - ivec2(velocity * vec2(BLUR_IMAGE_SIZE));

    vec3 reprojNormal       = UnpackNormal(texelFetch(u_GBufferCompactNormal, reprojP, 0).xyz);
    vec2 current_z_Values   = texelFetch(u_GBufferLinearZ, p, 0).xy;
    vec2 prev_z_Values      = texelFetch(u_GBufferPrevLinearZ, p, 0).xy;

    float validReprojection = ValidSample(BLUR_IMAGE_SIZE, reprojP, current_z_Values.x, prev_z_Values.x, current_z_Values.y, currentNormal, reprojNormal);
    vec4 prev_FinalColor_HistoryLength = imageLoad(u_DenoisedReflections, reprojP);

	historyLength = validReprojection * validSample * min(prev_FinalColor_HistoryLength.a + 1.0f, TEMPORAL_REUSE_MAX_HISTORY_LENGTH); 
	current_FinalColor_Valid.rgb = mix(
        current_FinalColor_Valid.rgb,
        prev_FinalColor_HistoryLength.rgb,
        historyLength / (TEMPORAL_REUSE_MAX_HISTORY_LENGTH + 1.0f));
#endif

    imageStore(u_DenoisedReflections, p, vec4(mix(vec3(1.0f, 0.0f, 0.0f), current_FinalColor_Valid.rgb, validReprojection), historyLength));
    //imageStore(u_DenoisedReflections, p, mix(vec4(1.0f, 0.0f, 0.0f, 1.0f), vec4(0.0f, 1.0f, 0.0f, 1.0f), validReprojection));
}