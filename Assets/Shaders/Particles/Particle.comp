#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#include "../Defines.glsl"
#include "../Helpers.glsl"

#define WORK_GROUP_INVOCATIONS 32
layout(local_size_x = WORK_GROUP_INVOCATIONS, local_size_y = 1, local_size_z = 1) in;

// Pushconstants
layout(push_constant) uniform PushConstants
{
	float   DeltaTime;
    uint    ParticleCount; 
} u_PC;

// Buffers
layout(binding = 0, set = BUFFER_SET_INDEX) restrict buffer ParticleInstances
{ 
	SParticle Val[]; 
} b_ParticleInstances;

layout(binding = 1, set = BUFFER_SET_INDEX) readonly restrict buffer EmitterInstances
{ 
	SEmitter Val[]; 
} b_EmitterInstances;

layout(binding = 2, set = BUFFER_SET_INDEX) readonly restrict buffer EmitterTransforms
{ 
	mat4 Val[]; 
} b_EmitterTransforms;

layout (binding = 3, set = BUFFER_SET_INDEX) uniform PerFrameBuffer
{
	SPerFrameBuffer perFrameBuffer;
} u_PerFrameBuffer;

layout(binding = 0, set = TEXTURE_SET_INDEX) uniform sampler2D u_DepthTexture;
layout(binding = 0, set = 2) uniform sampler2D u_NormalTexture;

// Main
void main()
{
	// Return in case this thread is outside of our ParticleCount
	uint totalInvocations = gl_NumWorkGroups.x * gl_WorkGroupSize.x;
	uint indexOffset = gl_GlobalInvocationID.x;
	SPerFrameBuffer frameBuffer = u_PerFrameBuffer.perFrameBuffer;
	const float dt = u_PC.DeltaTime;
	const vec3 GLOBAL_DOWN = vec3(0.f, 1.f, 0.f);

	while (indexOffset < u_PC.ParticleCount)
	{
		// Update particle data 
		SParticle particle = b_ParticleInstances.Val[indexOffset];
		SEmitter emitter = b_EmitterInstances.Val[particle.EmitterIndex];
		mat4 emitterTransform = b_EmitterTransforms.Val[particle.EmitterIndex];

		if(particle.WasCreated)
		{
			particle.WasCreated = false;
			particle.Transform[3].xyz = emitterTransform[3].xyz + particle.StartPosition;

			// Rotate the initial acceleration and velocity to match its emitter's.
			particle.Velocity = (emitterTransform*vec4(particle.StartVelocity, 0.f)).xyz;
			particle.Acceleration = (emitterTransform*vec4(particle.StartAcceleration, 0.f)).xyz;
		}

		vec3 nextPos = particle.Transform[3].xyz + particle.Velocity*dt;
		vec4 vpPos = frameBuffer.Projection * frameBuffer.View * vec4(nextPos, 1.f);
		vpPos.xy = vpPos.xy/vpPos.w * 0.5f + 0.5f;
		vpPos.y = 1.f - vpPos.y;
		vec2 uv = vpPos.xy;
		vec3 normal = UnpackNormal(texture(u_NormalTexture, uv).xyz);
		float depth = texture(u_DepthTexture, uv).r;
		float pDepth = vpPos.z/vpPos.w;
		if(vpPos.w < EPSILON)
			pDepth = 0.f;

		particle.Velocity += (particle.Acceleration + GLOBAL_DOWN*emitter.Gravity) * dt;
		if(pDepth > depth && uv.x > 0.f && uv.y > 0.f && uv.x <= 1.f && uv.y <= 1.f)
		{
			vec3 preV = particle.Velocity;
			particle.Velocity *= 0.9; // Friction
			particle.Velocity -= dot(preV, normal) * normal * 1.2f;
		}
		
		particle.Transform[3].xyz += particle.Velocity*dt;


		particle.CurrentLife -= dt;

		// If the particle is not visible, put it outside the view of the players.
		if(particle.CurrentLife > particle.LifeTime)
		{
			const float OUT_OF_REACH = 10000.f;
			particle.Transform[3].xyz = vec3(OUT_OF_REACH);
			particle.WasCreated = true;
		}

		// Should only happen if it is an emitter that repeats.
		if(particle.CurrentLife < 0.f)
		{
			float extraLife = mod(abs(particle.CurrentLife), particle.LifeTime);
			particle.CurrentLife = particle.LifeTime-extraLife;
			particle.Transform[3].xyz = particle.StartPosition + emitterTransform[3].xyz;
			particle.Velocity = particle.StartVelocity;
			particle.Velocity = (emitterTransform*vec4(particle.StartVelocity, 0.f)).xyz;
			particle.Acceleration = (emitterTransform*vec4(particle.StartAcceleration, 0.f)).xyz;
			particle.TileIndex = emitter.FirstAnimationIndex;
		}

		float t = clamp(particle.CurrentLife, 0.f, emitter.LifeTime)/emitter.LifeTime;
		particle.TileIndex = emitter.FirstAnimationIndex + emitter.AnimationCount-1 - clamp(uint(t*emitter.AnimationCount), 0, emitter.AnimationCount-1);

		b_ParticleInstances.Val[indexOffset] = particle;
		indexOffset += totalInvocations;
	}

}